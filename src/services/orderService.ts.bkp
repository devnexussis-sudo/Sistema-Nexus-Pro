
import { supabase, adminSupabase, publicSupabase } from '../lib/supabase';
import { AuthService } from './authService';
import { StorageService } from './storageService';
import { SessionStorage, GlobalStorage } from '../lib/sessionStorage';
import { CacheManager } from '../lib/cache';
import { ServiceOrder, OrderStatus, OrderItem } from '../types';
import { logger } from '../lib/logger';

const isCloudEnabled = !!(import.meta.env.VITE_SUPABASE_URL && import.meta.env.VITE_SUPABASE_ANON_KEY);
const STORAGE_KEYS = { ORDERS: 'nexus_orders_v2' }; // Replication of constant

// Helper para obter tenant ID (Redundant but safe copy to avoid circular deps or lazy loading issues)
const getCurrentTenantId = (): string | undefined => {
    try {
        const techSession = localStorage.getItem('nexus_tech_session_v2') || localStorage.getItem('nexus_tech_session');
        if (techSession) {
            const user = JSON.parse(techSession);
            const tid = user.tenantId || user.tenant_id;
            if (tid) return tid;
        }
        const userStr = SessionStorage.get('user') || GlobalStorage.get('persistent_user');
        if (userStr) {
            const user = typeof userStr === 'string' ? JSON.parse(userStr) : userStr;
            const tid = user.tenantId || user.tenant_id;
            if (tid) return tid;
        }
        const urlParams = new URLSearchParams(window.location.search);
        const urlTid = urlParams.get('tid') || SessionStorage.get('current_tenant');
        if (urlTid) return urlTid;
        return undefined;
    } catch (e) {
        return undefined;
    }
};

// Helper interno para acessar Service Client
const getServiceClient = () => {
    return adminSupabase;
};

// Helper session guard
const ensureValidSession = async (): Promise<boolean> => {
    try {
        const { data: session } = await supabase.auth.getSession();
        if (!session?.session) {
            // Tenta refresh
            const { data: refresh } = await supabase.auth.refreshSession();
            return !!refresh?.session;
        }
        return true;
    } catch {
        return false;
    }
};

export const OrderService = {

    // Helper para mapear ServiceOrder do Front (camelCase) para o DB (snake_case)
    _mapOrderToDB: (order: any) => {
        return {
            title: order.title,
            description: order.description,
            customer_name: order.customerName,
            customer_address: order.customerAddress,
            status: order.status,
            priority: order.priority,
            operation_type: order.operationType,
            assigned_to: order.assignedTo,
            form_id: order.formId,
            form_data: order.formData,
            equipment_name: order.equipmentName,
            equipment_model: order.equipmentModel,
            equipment_serial: order.equipmentSerial,
            scheduled_date: order.scheduledDate,
            scheduled_time: order.scheduledTime,
            start_date: order.startDate,
            end_date: order.endDate,
            notes: order.notes,
            items: order.items,
            show_value_to_client: order.showValueToClient,
            billing_status: order.billingStatus,
            payment_method: order.paymentMethod,
            paid_at: order.paidAt,
            billing_notes: order.billingNotes,
            linked_quotes: order.linkedQuotes || [],
            updated_at: new Date().toISOString()
        };
    },

    // Helper para mapear ServiceOrder do DB (snake_case) para o Front (camelCase)
    _mapOrderFromDB: (data: any): ServiceOrder => {
        // Mapeamento extra-resiliente para garantir que nada se perca entre Snake e Camel
        return {
            id: data.id,
            displayId: data.display_id || data.displayId,
            publicToken: data.public_token,
            tenantId: data.tenant_id || data.tenantId,
            title: data.title,
            description: data.description || data.description_text,
            customerName: data.customer_name || data.customerName || 'Cliente n√£o identificado',
            customerAddress: data.customer_address || data.customerAddress || '',
            status: data.status,
            priority: data.priority,
            operationType: data.operation_type || data.operationType || '',
            assignedTo: data.assigned_to || data.assignedTo,
            formId: data.form_id || data.formId,
            formData: OrderService.migrateSignatureData(data.form_data || data.formData || {}),
            equipmentName: data.equipment_name || data.equipmentName,
            equipmentModel: data.equipment_model || data.equipmentModel,
            equipmentSerial: data.equipment_serial || data.equipmentSerial,
            createdAt: data.created_at || data.createdAt || new Date().toISOString(),
            updatedAt: data.updated_at || data.updatedAt,
            scheduledDate: data.scheduled_date || data.scheduledDate || '',
            scheduledTime: data.scheduled_time || data.scheduledTime || '',
            startDate: data.start_date || data.startDate,
            endDate: data.end_date || data.endDate,
            notes: data.notes,
            items: data.items || [],
            showValueToClient: data.show_value_to_client ?? data.showValueToClient ?? false,
            billingStatus: data.billing_status || 'PENDING',
            paymentMethod: data.payment_method,
            paidAt: data.paid_at,
            billingNotes: data.billing_notes
        };
    },

    /**
     * üîÑ Nexus Migration Engine (Backward Compatibility)
     * Normaliza dados de assinatura em OS antigas para o novo formato sem√¢ntico.
     */
    migrateSignatureData: (formData: Record<string, any>): Record<string, any> => {
        if (!formData || Object.keys(formData).length === 0) return formData;

        const migrated = { ...formData };
        let signatureFound = false;

        // Procura por campos de assinatura com nomes antigos/gen√©ricos
        Object.entries(formData).forEach(([key, value]) => {
            const isImage = typeof value === 'string' && value.startsWith('data:image');
            const keyLower = key.toLowerCase();

            // Se encontrou uma imagem que parece ser assinatura mas n√£o tem nome sem√¢ntico
            if (isImage && !signatureFound &&
                (keyLower.includes('assinat') || keyLower.includes('sign') ||
                    keyLower === 'signature' || !isNaN(Number(key)))) {

                // Renomeia para o padr√£o esperado se ainda n√£o existir
                if (!migrated['Assinatura do Cliente']) {
                    migrated['Assinatura do Cliente'] = value;
                    signatureFound = true;

                    // Se o campo original era um ID num√©rico, remove para evitar duplica√ß√£o
                    if (!isNaN(Number(key))) {
                        delete migrated[key];
                    }
                }
            }
        });

        // Normaliza campos de metadados de assinatura
        const nameKeys = Object.keys(migrated).filter(k => k.toLowerCase().includes('nome') && !k.toLowerCase().includes('customer'));
        const cpfKeys = Object.keys(migrated).filter(k => k.toLowerCase().includes('cpf'));
        const birthKeys = Object.keys(migrated).filter(k => k.toLowerCase().includes('nascimento') || k.toLowerCase().includes('birth'));

        if (nameKeys.length > 0 && !migrated['Assinatura do Cliente - Nome']) {
            migrated['Assinatura do Cliente - Nome'] = migrated[nameKeys[0]];
        }
        if (cpfKeys.length > 0 && !migrated['Assinatura do Cliente - CPF']) {
            migrated['Assinatura do Cliente - CPF'] = migrated[cpfKeys[0]];
        }
        if (birthKeys.length > 0 && !migrated['Assinatura do Cliente - Nascimento']) {
            migrated['Assinatura do Cliente - Nascimento'] = migrated[birthKeys[0]];
        }

        return migrated;
    },


    /**
     * üìä Nexus Stats Engine - Lightweight Fetch
     * Fetches orders optimized for dashboard statistics (up to 5000 records).
     */
    getOrdersForStats: async (startDate?: string, endDate?: string): Promise<ServiceOrder[]> => {
        if (isCloudEnabled) {
            const tenantId = getCurrentTenantId();
            if (!tenantId) return [];

            // Timeout e Error Handling encapsulados
            try {
                let query = getServiceClient()
                    .from('orders')
                    .select('id, display_id, created_at, scheduled_date, status, assigned_to, end_date, customer_name, title')
                    .eq('tenant_id', tenantId)
                    .order('created_at', { ascending: false })
                    .limit(5000);

                if (startDate) query = query.gte('created_at', startDate);
                if (endDate) query = query.lte('created_at', endDate);

                const { data, error } = await query;

                if (error) {
                    console.error("‚ùå Erro ao buscar estat√≠sticas:", error);
                    return [];
                }

                // Mapeamento manual otimizado
                return (data || []).map((d: any) => ({
                    id: d.id,
                    displayId: d.display_id,
                    status: d.status,
                    createdAt: d.created_at,
                    scheduledDate: d.scheduled_date,
                    endDate: d.end_date,
                    assignedTo: d.assigned_to,
                    customerName: d.customer_name,
                    title: d.title,
                    // Campos obrigat√≥rios do tipo ServiceOrder preenchidos com defaults
                    tenantId: tenantId,
                    description: '',
                    customerAddress: '',
                    priority: 'M√âDIA' as any,
                    operationType: '',
                    items: [],
                    showValueToClient: false,
                    billingStatus: 'PENDING'
                } as any));
            } catch (e) {
                console.error("Nexus Stats Error:", e);
                return [];
            }
        }
        return [];
    },

    getOrders: async (): Promise<ServiceOrder[]> => {
        if (isCloudEnabled) {
            const MAX_RETRIES = 2;

            for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
                try {
                    // üõ°Ô∏è Session Guard: Validate/refresh token BEFORE the query
                    const sessionOk = await ensureValidSession();
                    if (!sessionOk) {
                        console.error(`‚ùå [getOrders] Attempt ${attempt + 1}: Session inv√°lida.`);
                        if (attempt < MAX_RETRIES - 1) {
                            await new Promise(r => setTimeout(r, 1500));
                            continue;
                        }
                        throw new Error('SESSION_EXPIRED_AUTH');
                    }

                    let tenantId = getCurrentTenantId();
                    if (!tenantId) {
                        throw new Error('SESSION_EXPIRED_NO_TENANT');
                    }

                    console.log(`üì° Nexus DataSync: Buscando Ordens (tentativa ${attempt + 1})...`);

                    // üõ°Ô∏è Timeout Protection: 20s
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 20000);

                    const { data, error } = await getServiceClient().from('orders')
                        .select('*')
                        .eq('tenant_id', tenantId)
                        .order('created_at', { ascending: false })
                        .limit(200)
                        .abortSignal(controller.signal);

                    clearTimeout(timeoutId);

                    if (error) {
                        // üîí Check for auth/session errors
                        if (error.message?.includes('JWT') ||
                            error.message?.includes('expired') ||
                            error.message?.includes('auth') ||
                            error.code === 'PGRST301') {

                            if (attempt < MAX_RETRIES - 1) {
                                // Force token refresh and retry
                                await supabase.auth.refreshSession();
                                await new Promise(r => setTimeout(r, 1000));
                                continue;
                            }
                            throw new Error('SESSION_EXPIRED_AUTH');
                        }
                        throw error;
                    }

                    const mapped = (data || []).map(d => OrderService._mapOrderFromDB(d));

                    // Atualiza cache local silenciosamente
                    localStorage.setItem(STORAGE_KEYS.ORDERS, JSON.stringify(mapped));

                    return mapped;

                } catch (err: any) {
                    if (err?.name === 'AbortError') {
                        if (attempt < MAX_RETRIES - 1) continue;
                        return [];
                    }
                    // Generic error on last attempt
                    if (attempt >= MAX_RETRIES - 1) {
                        console.error("‚ùå Erro ao buscar ordens:", err.message);
                        const cached = localStorage.getItem(STORAGE_KEYS.ORDERS);
                        if (cached) {
                            console.warn("‚ö†Ô∏è Usando dados em cache devido a erro.");
                            return JSON.parse(cached);
                        }
                        return [];
                    }
                }
            }
            return [];
        }
        return [];
    },

    /**
     * üöÄ Nexus Paginated Orders - Server-Side Pagination
     */
    getOrdersPaginated: async (
        page: number = 1,
        limit: number = 5,
        technicianId?: string,
        filters?: { status?: OrderStatus; startDate?: string; endDate?: string }
    ): Promise<{ orders: ServiceOrder[]; total: number }> => {
        if (isCloudEnabled) {
            const tenantId = getCurrentTenantId();

            if (!tenantId) {
                console.warn("‚ö†Ô∏è Tenant ID n√£o encontrado.");
                return { orders: [], total: 0 };
            }

            const from = (page - 1) * limit;
            const to = from + limit - 1;

            let query = getServiceClient()
                .from('orders')
                .select('*', { count: 'exact' })
                .eq('tenant_id', tenantId);

            // Filtra por t√©cnico se especificado
            if (technicianId) {
                query = query.eq('assigned_to', technicianId);
            }

            // üîç Filtros Avan√ßados
            if (filters?.status && filters.status !== 'ALL' as any) {
                query = query.eq('status', filters.status);
            }
            if (filters?.startDate) {
                query = query.gte('scheduled_date', filters.startDate); // ou created_at
            }
            if (filters?.endDate) {
                query = query.lte('scheduled_date', filters.endDate);
            }

            const { data, error, count } = await query
                .order('created_at', { ascending: false })
                .range(from, to);

            if (error) {
                console.error("‚ùå Erro ao buscar ordens paginadas:", error.message);
                return { orders: [], total: 0 };
            }

            const mapped = (data || []).map(d => OrderService._mapOrderFromDB(d));
            return { orders: mapped, total: count || 0 };
        }

        return { orders: [], total: 0 };
    },

    createOrder: async (order: Omit<ServiceOrder, 'id' | 'createdAt' | 'updatedAt'>): Promise<ServiceOrder> => {
        // üõ°Ô∏è Nexus Timeout Protection (20s)
        const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('TIMEOUT_20S')), 20000));

        try {
            const createFlow = (async () => {
                const tid = getCurrentTenantId();

                if (!tid) {
                    throw new Error("Tenant ID n√£o encontrado.");
                }

                if (isCloudEnabled) {
                    console.log("üöÄ DEBUG_V3_DIRECT_DB: Iniciando cria√ß√£o de OS...");

                    // 1. GERAR ID SEQUENCIAL (RPC)
                    const { data: seqNum, error: seqError } = await getServiceClient().rpc('get_next_order_id', {
                        p_tenant_id: tid
                    });

                    if (seqError) {
                        console.error("‚ùå Erro RPC get_next_order_id:", seqError);
                        throw new Error(`Falha ao gerar n√∫mero da OS (RPC): ${seqError.message}`);
                    }

                    // 2. OBTER PREFIXO DO TENANT
                    const { data: tenantData } = await getServiceClient()
                        .from('tenants')
                        .select('os_prefix')
                        .eq('id', tid)
                        .single();

                    const prefix = tenantData?.os_prefix || 'OS-';
                    const finalId = `${prefix}${seqNum}`;

                    // 3. PREPARAR PAYLOAD (Mapeamento snake_case)
                    const dbPayload = {
                        ...OrderService._mapOrderToDB(order),
                        id: finalId,
                        tenant_id: tid,
                        created_at: new Date().toISOString()
                    };

                    // 4. INSERIR NO BANCO
                    const { data: insertedData, error: insertError } = await getServiceClient()
                        .from('orders')
                        .insert(dbPayload)
                        .select()
                        .single();

                    if (insertError) {
                        console.error("‚ùå Erro ao inserir OS:", insertError);
                        throw new Error(`Falha no banco de dados: ${insertError.message}`);
                    }

                    return OrderService._mapOrderFromDB(insertedData);
                }
                throw new Error('Cloud required for creating orders.');
            })();

            return await Promise.race([createFlow, timeoutPromise]) as ServiceOrder;

        } catch (err: any) {
            if (err.message === 'TIMEOUT_20S') {
                throw new Error("O servidor demorou muito para processar a cria√ß√£o. Verifique sua conex√£o e tente novamente.");
            }
            throw err;
        }
    },

    updateOrder: async (updatedOrder: ServiceOrder): Promise<ServiceOrder> => {
        if (isCloudEnabled) {
            // üõ°Ô∏è Nexus Timeout Protection (15s)
            const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('TIMEOUT_15S')), 15000));

            try {
                const updatePromise = (async () => {
                    const dbPayload = OrderService._mapOrderToDB(updatedOrder);

                    const tid = getCurrentTenantId();
                    if (!tid) throw new Error("Tenant n√£o identificado.");

                    const { data, error } = await getServiceClient().from('orders')
                        .update(dbPayload)
                        .eq('id', updatedOrder.id)
                        .eq('tenant_id', tid)
                        .select()
                        .single();

                    if (error) throw error;
                    return OrderService._mapOrderFromDB(data);
                })();

                return await Promise.race([updatePromise, timeoutPromise]) as ServiceOrder;

            } catch (err: any) {
                if (err.message === 'TIMEOUT_15S') {
                    throw new Error("O sistema demorou muito para responder. Verifique sua conex√£o e tente novamente.");
                }
                throw err;
            }
        }
        return updatedOrder;
    },

    updateOrderStatus: async (id: string, status: OrderStatus, notes?: string, data?: any, items?: OrderItem[]): Promise<void> => {
        if (!isCloudEnabled) return;

        let processedData = data;

        // 1. Processamento de Imagens (Opcional - usando StorageService agora)
        if (data && typeof data === 'object') {
            processedData = { ...data };

            const safeUpload = async (base64: string): Promise<string> => {
                const timeout = new Promise<string>((_, reject) => setTimeout(() => reject(new Error("Timeout")), 20000));
                try {
                    const result = await Promise.race([StorageService.uploadFile(base64, `orders/${id}/evidence`), timeout]);
                    return result as string;
                } catch (err) {
                    console.error("Upload falhou ou timeout:", err);
                    return '[FALHA_NO_UPLOAD - TENTE NOVAMENTE]';
                }
            };

            for (const [key, value] of Object.entries(processedData)) {
                if (typeof value === 'string' && value.startsWith('data:image')) {
                    processedData[key] = await safeUpload(value);
                } else if (Array.isArray(value)) {
                    const newArray = [];
                    for (const item of value) {
                        newArray.push((typeof item === 'string' && item.startsWith('data:image')) ? await safeUpload(item) : item);
                    }
                    processedData[key] = newArray;
                }
            }
        }

        // 2. Prepara√ß√£o do Payload
        const updatePayload: any = {
            status,
            updated_at: new Date().toISOString()
        };

        if (notes !== undefined) updatePayload.notes = notes;
        if (processedData !== undefined) updatePayload.form_data = processedData;
        if (items !== undefined) updatePayload.items = items;

        if (status === OrderStatus.IN_PROGRESS) {
            updatePayload.start_date = new Date().toISOString();
        } else if (status === OrderStatus.COMPLETED || status === OrderStatus.BLOCKED) {
            updatePayload.end_date = new Date().toISOString();
        }

        // 3. Sync Database
        const tid = getCurrentTenantId();

        const dbPromise = supabase.from('orders').update(updatePayload)
            .eq('id', id)
            .eq('tenant_id', tid);

        const timeoutPromise = new Promise<{ error: any }>((_, reject) =>
            setTimeout(() => reject(new Error("Database Request Timeout")), 10000)
        );

        const { error } = await Promise.race([dbPromise, timeoutPromise]) as any;

        if (error) {
            throw {
                message: "Erro ao salvar no Banco de Dados",
                code: error.code,
                pg_message: error.message
            };
        }
    },

    getPublicOrderById: async (id: string, retryCount = 0): Promise<ServiceOrder | null> => {
        if (isCloudEnabled) {
            // üõ°Ô∏è ESTRAT√âGIA 1: Tentar RPC Seguro (Ideal)
            try {
                const { data, error } = await publicSupabase.rpc('get_public_order', { search_term: id });

                if (!error && data && (Array.isArray(data) ? data.length > 0 : true)) {
                    const orderData = Array.isArray(data) ? data[0] : data;
                    return OrderService._mapOrderFromDB(orderData);
                }

            } catch (err: any) {
                if (err?.name === 'AbortError' || err?.message?.includes('Lock')) {
                    if (retryCount < 3) {
                        await new Promise(r => setTimeout(r, 1000 + (retryCount * 500)));
                        return OrderService.getPublicOrderById(id, retryCount + 1);
                    }
                }
            }

            // üîÑ ESTRAT√âGIA 2: Fallback - Admin Bypassing RLS
            try {
                const isUuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(id) ||
                    /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(id);

                let query = adminSupabase.from('orders').select('*');

                if (isUuid) {
                    query = query.eq('public_token', id);
                } else {
                    query = query.eq('id', id);
                }

                const { data, error } = await query.single();
                if (error || !data) return null;
                return OrderService._mapOrderFromDB(data);
            } catch (fallbackErr) {
                return null;
            }
        }
        return null;
    },

    subscribeToOrders: (onUpdate: () => void) => {
        if (!isCloudEnabled) return { unsubscribe: () => { } };

        let channel: any = null;
        let isActive = true;
        let reconnectAttempts = 0;
        let reconnectTimer: any = null;

        const connect = async () => {
            if (!isActive) return;

            const tenantId = getCurrentTenantId();
            if (!tenantId) return;

            await ensureValidSession();

            channel = supabase
                .channel(`orders-live-${tenantId}`)
                .on(
                    'postgres_changes',
                    { event: '*', schema: 'public', table: 'orders', filter: `tenant_id=eq.${tenantId}` },
                    (payload) => {
                        if (!isActive) return;
                        onUpdate();
                    }
                )
                .subscribe(async (status) => {
                    if (!isActive) return;
                    if (status === 'SUBSCRIBED') {
                        reconnectAttempts = 0;
                    }
                    if (status === 'CHANNEL_ERROR' || status === 'CLOSED' || status === 'TIMED_OUT') {
                        if (reconnectAttempts < 5) {
                            const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
                            reconnectAttempts++;
                            reconnectTimer = setTimeout(async () => {
                                if (channel) await supabase.removeChannel(channel).catch(() => { });
                                connect();
                            }, delay);
                        }
                    }
                });
        };

        connect();

        return {
            unsubscribe: () => {
                isActive = false;
                if (reconnectTimer) clearTimeout(reconnectTimer);
                if (channel) supabase.removeChannel(channel).catch(() => { });
            }
        };
    }
};
